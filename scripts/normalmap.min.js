!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var n;n="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,n.normalmap=e()}}(function(){return function e(n,r,a){function t(o,s){if(!r[o]){if(!n[o]){var l="function"==typeof require&&require;if(!s&&l)return l(o,!0);if(i)return i(o,!0);var u=Error("Cannot find module '"+o+"'");throw u.code="MODULE_NOT_FOUND",u}var f=r[o]={exports:{}};n[o][0].call(f.exports,function(e){var r=n[o][1][e];return t(r?r:e)},f,f.exports,e,n,r,a)}return r[o].exports}for(var i="function"==typeof require&&require,o=0;o<a.length;o++)t(a[o]);return t}({1:[function(e,n,r){function a(e,n,r,a,t,i){n=n||e.drawingBufferWidth,r=r||e.drawingBufferHeight,this.width=n,this.height=r,this.gl=e,this.framebuffer=e.createFramebuffer(),e.bindFramebuffer(e.FRAMEBUFFER,this.framebuffer),this.texture=e.createTexture(),e.bindTexture(e.TEXTURE_2D,this.texture),e.texImage2D(e.TEXTURE_2D,0,t||e.RGBA,n,r,0,t||e.RGBA,a||e.UNSIGNED_BYTE,null),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),i&&(this.depth=e.createRenderbuffer(),e.bindRenderbuffer(e.RENDERBUFFER,this.depth),e.renderbufferStorage(e.RENDERBUFFER,e.DEPTH_COMPONENT16,n,r),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.RENDERBUFFER,this.depth)),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,this.texture,0),this.supported=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE,e.viewport(0,0,n,r),e.bindTexture(e.TEXTURE_2D,null),e.bindRenderbuffer(e.RENDERBUFFER,null),e.bindFramebuffer(e.FRAMEBUFFER,null)}a.prototype={bind:function(){this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,this.framebuffer)},unbind:function(){this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,null)}},n.exports=a},{}],2:[function(e,n,r){function a(e){function n(){R=x.width/x.height,M=e.repeat?x.width/N:1,O&&(e.singlePass||(D.unbind(),D=T(O),D.bind()),O.viewport(0,0,O.drawingBufferWidth,O.drawingBufferHeight))}function r(){var n={premultipliedAlpha:!0,alpha:!0,depth:!1};return(O=x.getContext("webgl",n)||x.getContext("experimental-webgl",n))?(O.blendColor(0,0,0,0),O.clearColor(0,0,0,0),C=i(O),O.enableVertexAttribArray(0),O.bindBuffer(O.ARRAY_BUFFER,C),O.vertexAttribPointer(0,3,O.FLOAT,!1,0,0),O.enable(O.BLEND),O.enable(O.DITHER),O.disable(O.DEPTH_TEST),O.blendFuncSeparate(O.SRC_ALPHA,O.ONE,O.ONE,O.ZERO),w=new g(O,d),e.singlePass||(y=null,D=T(O),D.bind()),O.viewport(0,0,O.drawingBufferWidth,O.drawingBufferHeight),a(),void(window.gl=O)):void console.warn("webgl not supported!")}function a(){s(O,e),f()}function o(e,n){return w.get("vertex",e+"-fragment",u(n||{},A))}function f(){t(A,e),F=o("light",{IS_POINT_LIGHT:1}),U=o("light",{IS_DIRECTIONAL_LIGHT:1}),I=o("render")}function c(){return{uTextureAspect:e.repeat?R*P:1,uScale:M}}function m(n){var r=u(c(),{uLightColor:n,uMetalness:e.metalness,uRoughness:e.roughness,uBaseColor:e.baseColor,uNormalSampler:v});return e.baseColorMap&&(r.uBaseColorSampler=E),e.materialMap&&(r.uMaterialSampler=p),e.subSurfaceScattering&&(r.uSubSurfaceScattering=e.subSurfaceScattering),e.singlePass&&e.ambientMap&&(r.uAmbientSampler=b,r.uAmbient=e.ambient),r}function T(e){var n;if(y)return new h(e,void 0,void 0,y,B);var r=e.getExtension("OES_texture_half_float"),a=e.getExtension("OES_texture_half_float_linear");if(r&&a&&(n=new h(e,void 0,void 0,r.HALF_FLOAT_OES),n.supported))return y=r.HALF_FLOAT_OES,n;e.getExtension("OES_texture_float"),e.getExtension("OES_texture_float_linear");y=e.UNSIGNED_BYTE;var t=e.getExtension("EXT_sRGB");return t&&(n=new h(e,void 0,void 0,e.UNSIGNED_BYTE,t.SRGB_ALPHA_EXT),n.supported)?(B=t.SRGB_ALPHA_EXT,n):new h(e)}e=u({metalness:1,roughness:1,ambient:1,baseColor:new Float32Array([.5,.5,.5])},e);var x=e.canvas;if(null==x)throw Error("normalmap() canvas is required");if(null==e.normalMap)throw Error("normalmap() normalMap is required");var A={};t(A,e);var R,M,N=e.normalMap.naturalWidth||e.normalMap.width,L=e.normalMap.naturalHeight||e.normalMap.height,P=N/L;n();var w,F,U,I,C,D,O;x.addEventListener("webglcontextlost",function(e){O=null,console.warn("lost webgl context!"),e.preventDefault()},!1),x.addEventListener("webglcontextrestored",function(){console.warn("webgl context restored!"),r(),e.onContextRestored&&e.onContextRestored()},!1),r();var B,y=null,X={canvas:x,addPointLight:function(n,r){if(O){e.singlePass&&O.clear(O.COLOR_BUFFER_BIT),F.use();var a=m(r);a.uLightPosition=n,a.uViewportAspect=R,F.uniforms(a),l(O)}},addDirectionalLight:function(n,r){if(O){e.singlePass&&O.clear(O.COLOR_BUFFER_BIT),U.use();var a=m(r);a.uLightDirection=n,U.uniforms(a),l(O)}},render:function(){if(O&&!e.singlePass){D.unbind(),O.activeTexture(O.TEXTURE0+_),O.bindTexture(O.TEXTURE_2D,D.texture),I.use();var n={uFrameBufferSampler:_};e.antiAliasing&&(n.uFrameBufferResolution=new Float32Array([D.width,D.height])),e.ambientMap&&(u(n,c()),n.uAmbientSampler=b,n.uAmbient=e.ambient),I.uniforms(n),O.clear(O.COLOR_BUFFER_BIT),l(O),D.bind(),O.clear(O.COLOR_BUFFER_BIT)}},configure:function(n){S.forEach(function(e){if(e in n)throw new TypeError("can't configure()"+e)}),u(e,n),O&&a()},resize:n};return X}function t(e,n){e.USE_BASE_COLOR_MAP=n.baseColorMap&&1,e.USE_MATERIAL_MAP=n.materialMap&&1,e.USE_AMBIENT_MAP=n.ambientMap&&1,e.USE_SSS=n.subSurfaceScattering&&1,e.USE_FXAA=n.antiAliasing?1:void 0,e.USE_SINGLE_PASS=n.singlePass?1:void 0}function i(e){var n=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,n);var r=new Float32Array([1,1,0,-1,1,0,1,-1,0,-1,-1,0]);return e.bufferData(e.ARRAY_BUFFER,r,e.STATIC_DRAW),n}function o(e,n,r,a){var t=e.createTexture();e.bindTexture(e.TEXTURE_2D,t),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,!1),e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL,e.NONE);var i=c(n);return e.texImage2D(e.TEXTURE_2D,0,r||e.RGBA,r||e.RGBA,e.UNSIGNED_BYTE,n),i?(e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR_MIPMAP_LINEAR)):(e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR)),a&&i?(e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.REPEAT),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.REPEAT)):(e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),i&&e.generateMipmap(e.TEXTURE_2D),t}function s(e,n){if(null==n.normalMap)throw Error("normalmap() normalMap attribute is required");e.activeTexture(e.TEXTURE0+v),o(e,n.normalMap,e.RGBA,n.repeat),n.baseColorMap&&(e.activeTexture(e.TEXTURE0+E),o(e,n.baseColorMap,e.RGB,n.repeat)),n.materialMap&&(e.activeTexture(e.TEXTURE0+p),o(e,n.materialMap,e.RGB,n.repeat)),n.ambientMap&&(e.activeTexture(e.TEXTURE0+b),o(e,n.ambientMap,e.RGBA,n.repeat))}function l(e){e.drawArrays(e.TRIANGLE_STRIP,0,4)}function u(e){for(var n=1;n<arguments.length;n++){var r=arguments[n];for(var a in r)r.hasOwnProperty(a)&&(e[a]=r[a])}return e}function f(e,n,r){var a=new Float32Array(3);return a[0]=e,a[1]=n,a[2]=r,a}function c(e){return m(e.naturalWidth||e.width)&&m(e.naturalHeight||e.height)}function m(e){return 0!==e&&!(e&e-1)}var d={shaders:{ambient:e("./shaders/ambient.glsl"),brdf:e("./shaders/brdf.glsl"),common:e("./shaders/common.glsl"),fxaa:e("./shaders/fxaa.glsl"),"light-fragment":e("./shaders/light-fragment.glsl"),"render-fragment":e("./shaders/render-fragment.glsl"),"render-vertex":e("./shaders/render-vertex.glsl"),vertex:e("./shaders/vertex.glsl")}}.shaders,g=e("./shader-manager"),h=e("./fbo");const v=0,E=1,p=2,b=3,_=4;var S="canvas repeat singlePass".split();n.exports=a,a.vec3=f},{"./fbo":1,"./shader-manager":3,"./shaders/ambient.glsl":5,"./shaders/brdf.glsl":6,"./shaders/common.glsl":7,"./shaders/fxaa.glsl":8,"./shaders/light-fragment.glsl":9,"./shaders/render-fragment.glsl":10,"./shaders/render-vertex.glsl":11,"./shaders/vertex.glsl":12}],3:[function(e,n,r){function a(e,n,r){this.gl=e,this.sources=n,this.shaders=[],r=r||{},this.prefix=r.prefix||"",this.sourceIds=Object.create(null),this.sourceId=1}function t(e){if(!e)return"";var n=[];for(var r in e)null!=e[r]&&n.push("#define "+r+" "+e[r]);return n.join("\n")}var i=e("./shader");n.exports=a,a.prototype={includeExpression:/#include "([^"]+)"/,preprocess:function(e,n,r){for(var a=this.getSourceId(e),t=n.split("\n"),i=["#line 1 "+a],o=0;o<t.length;o++){var s=t[o],l=s.match(this.includeExpression);if(l){var u=l[1];r[u]?i.push("// "+s):(i.push(this.getSource(u,{},r)),i.push("#line "+(o+2)+" "+a),r[u]=!0)}else i.push(s)}return i.join("\n")},getSource:function(e,n,r){e=e.replace(/\.\w+$/,"");var a=this.sources[this.prefix+e];if(null==a)throw Error("shader not found "+e);return t(n)+this.preprocess(e,a,r)},getSourceId:function(e){return e in this.sourceIds||(this.sourceIds[e]=this.sourceId++),this.sourceIds[e]},getSourceName:function(e){var n=this.sourceIds;for(var r in n)if(n[r]===e)return r},get:function(e,n,r){n||(n=e);var a=JSON.stringify([e,n,r]);if(!(a in this.shaders))try{this.shaders[a]=new i(this.gl,this.getSource(e,r,{}),this.getSource(n,r,{}))}catch(e){throw this.resolveError(e)}return this.shaders[a]},resolveError:function(e){if(!e.message||!e.message.match(/Shader (compiler|linker) error:/))return e;var n=/(ERROR: )(\d+)(:\d+:)/g,r=e.message.replace(n,function(e,n,r,a){var t=this.getSourceName(1*r)||"unknown-"+r;return n+t+a}.bind(this));return r===e.message?e:Error(r)}}},{"./shader":4}],4:[function(e,n,r){function a(e,n,r){this.gl=e,this.program=l(e,n,r),this.uniformInfos=o(e,this.program),this.uniformValues=Object.create(null),this.uniformTypes=Object.create(null),this.attributeLocations=Object.create(null)}function t(e,n){switch(n){case e.FLOAT:case e.INT:case e.UNSIGNED_INT:case e.SAMPLER_2D:case e.SAMPLER_CUBE:case e.BOOL:return!0;default:return!1}}function i(e,n,r,a){switch(r){case e.FLOAT:e.uniform1f(n,a);break;case e.INT:case e.UNSIGNED_INT:case e.SAMPLER_2D:case e.SAMPLER_CUBE:case e.BOOL:e.uniform1i(n,a);break;case e.FLOAT_VEC3:e.uniform3fv(n,a);break;case e.FLOAT_VEC2:e.uniform2fv(n,a);break;case e.FLOAT_VEC4:e.uniform4fv(n,a);break;case e.FLOAT_MAT4:e.uniformMatrix4fv(n,a);break;case e.FLOAT_MAT3:e.uniformMatrix3fv(n,a);break;case e.FLOAT_MAT2:e.uniformMatrix2fv(n,a);break;case e.INT_VEC3:e.uniform3iv(n,a);break;case e.INT_VEC2:e.uniform2iv(n,a);break;case e.INT_VEC4:e.uniform4iv(n,a);break;default:console.warn("Unknown uniform type",name,r)}}function o(e,n){for(var r=Object.create(null),a=e.getProgramParameter(n,e.ACTIVE_UNIFORMS),t=0;a>t;t++){var i=e.getActiveUniform(n,t);r[i.name]={type:i.type,size:i.size,location:e.getUniformLocation(n,i.name)}}return r}function s(e,n,r){var a=e.createShader(n);if(e.shaderSource(a,r),e.compileShader(a),!e.getShaderParameter(a,e.COMPILE_STATUS))throw Error('Shader compiler error: "'+e.getShaderInfoLog(a)+'"');return a}function l(e,n,r){var a=s(e,e.FRAGMENT_SHADER,r),t=s(e,e.VERTEX_SHADER,n),i=e.createProgram();if(e.attachShader(i,t),e.attachShader(i,a),e.bindAttribLocation(i,0,"aPosition"),e.linkProgram(i),!e.getProgramParameter(i,e.LINK_STATUS))throw Error("Shader linker error: "+e.getProgramInfoLog(i));return i}function u(e,n){for(var r=!0,a=0;a<e.length;a++)e[a]!==n[a]&&(e[a]=n[a],r=!1);return r}n.exports=a,a.prototype={use:function(){this.gl.useProgram(this.program)},uniforms:function(e){for(var n in e)this.setUniform(n,e[n])},setUniform:function(e,n){var r=this.uniformInfos[e];if(!r)return void console.warn("shader missing uniform",e);var a=r.type;if(t(this.gl,a)){if(n===this.uniformValues[e])return;this.uniformValues[e]=n}else{var o=this.uniformValues[e];if(void 0!==o){if(u(o,n))return}else this.uniformValues[e]=new Float32Array(n)}i(this.gl,r.location,a,n)},getUniformLocation:function(e){if(!(e in this.uniformLocations)){var n=this.gl.getUniformLocation(this.program,e);0>n&&console.warn("shader missing uniform",e),this.uniformLocations[e]=n}return this.uniformLocations[e]},getAttribLocation:function(e){if(!(e in this.attributeLocations)){var n=this.gl.getAttribLocation(this.program,e);0>n&&console.warn("shader missing attribute",e),this.attributeLocations[e]=n}return this.attributeLocations[e]}}},{}],5:[function(e,n,r){n.exports="#ifdef USE_AMBIENT_MAP\nuniform sampler2D uAmbientSampler;\nuniform float uAmbient;\n\nvoid addAmbient(inout vec4 fragColor){\n    vec4 ambient = texture2D(uAmbientSampler, vUv);\n    ambient.rgb *= uAmbient * ambient.a;\n    fragColor.rgb = fragColor.rgb*fragColor.a + ambient.rgb;\n    // this is a bit of a hack but it allows for a separate alpha in both\n    // while not messing up when they are blended\n    fragColor.a = max(fragColor.a, ambient.a);\n}\n#endif\n"},{}],6:[function(e,n,r){n.exports='#include "common.glsl"\n\n// Epic approximation of schlicks\n// F0 is the specular reflectance at normal incidence.\n// via: http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\nvec3 F_schlick( vec3 F0, float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - F0 ) * fresnel + F0;\n}\n\n// normal distribution\n// alpha = roughness^2\n// via: http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\nfloat D_ggx(const in float dotNH, const in float alpha) {\n    float alphaSquared = alpha * alpha;\n    float denominator = dotNH*dotNH * (alphaSquared - 1.0) + 1.0;\n    return (alphaSquared) / (PI * denominator*denominator);\n}\n\n// geometric attenuation\n// http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\nfloat G_ggx(const in float dotNL, const in float dotNV, const in float roughness) {\n    float k = (roughness + 1.0);\n    k = k*k / 8.0;\n    float l = dotNL / ( dotNL * (1.0-k) + k);\n    float v = dotNV / ( dotNV * (1.0-k) + k);\n    return l * v;\n}\n\n// n = normal\n// l = light direction\n// v = view direction\n// F0 specular color\n// h = half angle between l and v\nvec3 brdf_ggx(vec3 n, vec3 l, vec3 v, vec3 F0, float roughness) {\n    float alpha = roughness * roughness;\n    vec3 h = normalize(l + v);\n\n    float dotNL = saturate(dot(n, l));\n    float dotNV = saturate(dot(n, v));\n    float dotNH = saturate(dot(n, h));\n    float dotLH = saturate(dot(l, h));\n\n    vec3 F = F_schlick(F0, dotLH);\n    float D = D_ggx(dotNH, alpha);\n    float G = G_ggx(dotNL, dotNV, roughness);\n\n    return F * ( G * D );\n}\n'},{}],7:[function(e,n,r){n.exports="#define saturate(x) clamp(x, 0.0, 1.0)\nconst float PI = 3.14159265359;\nconst float RECIPROCAL_PI = 1.0 / PI;\nconst float EPSILON = 1e-30;\n\nfloat gammaEncode(const in float linear){\n    return pow(linear, 1.0/2.2);\n}\nvec3 gammaEncode(const in vec3 linear) {\n    return pow(linear, vec3(1.0/2.2));\n}\nvec4 gammaEncode(const in vec4 linear) {\n    return vec4(pow(linear.rgb, vec3(1.0/2.2)), linear.a);\n}\n\nvec3 gammaDecode(const in vec3 linear) {\n    return pow(linear, vec3(2.2));\n}\n"},{}],8:[function(e,n,r){n.exports="// based on nvidia fxaa 3.11 console https://gist.github.com/bkaradzic/6011431\n// https://github.com/mitsuhiko/webgl-meincraft/blob/master/assets/shaders/fxaa.glsl\n// it has been modified with little testing and is quite possibly broken now.\n\n//   0.125 leaves less aliasing, but is softer (default!!!)\n//   0.25 leaves more aliasing, and is sharper\nconst float fxaaEdgeThreshold = 0.125;\n//   0.06 - faster but more aliasing in darks\n//   0.05 - default\n//   0.04 - slower and less aliasing in darks\nconst float fxaaConsoleEdgeThresholdMin = 0.00;\n\n//   8.0 is sharper (default!!!)\n//   4.0 is softer\n//   2.0 is really soft (good only for vector graphics inputs)\nconst float fxaaConsoleEdgeSharpness = 8.0;\n\n// for some reason fxaa wants gamma encoded values\n// so I gamma encode on the fly\nfloat fxaaLuma(vec4 color){\n    const vec4 luma = vec4(0.299, 0.587, 0.114, 0.0);\n    return gammaEncode(dot(saturate(color), luma));\n}\n\nvec4 fxaa(vec2 uv, const vec2 resolution, sampler2D sampler) {\n    //     N = 0.50 (default)\n    //     N = 0.33 (sharper)\n    vec4 fxaaConsoleRcpFrameOpt = vec4(0.33) / vec4(-resolution.x, -resolution.y, resolution.x, resolution.y);\n    vec4 fxaaConsoleRcpFrameOpt2 = vec4(2.0) / vec4(-resolution.x, -resolution.y, resolution.x, resolution.y);\n\n    // vec2 inverseVP = vec2(1.0 / uViewportSize.x, 1.0 / uViewportSize.y);\n    vec2 pixelOffset = vec2(1.0)/resolution;\n\n    vec4 rgbNw = texture2D(sampler, (uv + vec2(-1.0, -1.0)) * pixelOffset);\n    vec4 rgbNe = texture2D(sampler, (uv + vec2(1.0, -1.0)) * pixelOffset);\n    vec4 rgbSw = texture2D(sampler, (uv + vec2(-1.0, 1.0)) * pixelOffset);\n    vec4 rgbSe = texture2D(sampler, (uv + vec2(1.0, 1.0)) * pixelOffset);\n    vec4 rgbM  = texture2D(sampler, uv);\n\n    // ffxaa wants luma to be\n    float lumaNw = fxaaLuma(rgbNw);\n    float lumaNe = fxaaLuma(rgbNe);\n    float lumaSw = fxaaLuma(rgbSw);\n    float lumaSe = fxaaLuma(rgbSe);\n    float lumaM  = fxaaLuma(rgbM);\n\n    float lumaMaxNwSw = max(lumaNw, lumaSw);\n    lumaNe += 1.0/384.0;\n    float lumaMinNwSw = min(lumaNw, lumaSw);\n\n    float lumaMaxNeSe = max(lumaNe, lumaSe);\n    float lumaMinNeSe = min(lumaNe, lumaSe);\n\n    float lumaMax = max(lumaMaxNeSe, lumaMaxNwSw);\n    float lumaMin = min(lumaMinNeSe, lumaMinNwSw);\n\n    float lumaMaxScaled = lumaMax * fxaaEdgeThreshold;\n\n    float lumaMinM = min(lumaMin, lumaM);\n    float lumaMaxScaledClamped = max(fxaaConsoleEdgeThresholdMin, lumaMaxScaled);\n    float lumaMaxM = max(lumaMax, lumaM);\n    float dirSwMinusNe = lumaSw - lumaNe;\n    float lumaMaxSubMinM = lumaMaxM - lumaMinM;\n    float dirSeMinusNw = lumaSe - lumaNw;\n    // early out\n    // if(lumaMaxSubMinM < lumaMaxScaledClamped) return vec4(1.0, 0.0, 0.0, 1.0);\n    if(lumaMaxSubMinM < lumaMaxScaledClamped) return rgbM;\n\n    vec2 dir = dirSwMinusNe + vec2(dirSeMinusNw, -dirSeMinusNw);\n\n    vec2 dir1 = normalize(dir.xy);\n    // this is suboptimal. It would probably be more efficient to do this in another stage.\n    vec4 rgbyN1 = gammaEncode(saturate(texture2D(sampler, uv - dir1 * fxaaConsoleRcpFrameOpt.zw)));\n    vec4 rgbyP1 = gammaEncode(saturate(texture2D(sampler, uv + dir1 * fxaaConsoleRcpFrameOpt.zw)));\n\n    float dirAbsMinTimesC = min(abs(dir1.x), abs(dir1.y)) * fxaaConsoleEdgeSharpness;\n    vec2 dir2 = clamp(dir1.xy / dirAbsMinTimesC, -2.0, 2.0);\n\n    vec4 rgbyN2 = gammaEncode(saturate(texture2D(sampler, uv - dir2 * fxaaConsoleRcpFrameOpt2.zw)));\n    vec4 rgbyP2 = gammaEncode(saturate(texture2D(sampler, uv + dir2 * fxaaConsoleRcpFrameOpt2.zw)));\n\n    vec4 rgbyA = rgbyN1 + rgbyP1;\n    vec4 rgbyB = ((rgbyN2 + rgbyP2) * 0.25) + (rgbyA * 0.25);\n\n    bool twoTap = (rgbyB.y < lumaMin) || (rgbyB.y > lumaMax);\n\n    if(twoTap) rgbyB.xyz = rgbyA.xyz * 0.5;\n\n    return rgbyB;\n}\n"},{}],9:[function(e,n,r){n.exports='precision highp float;\n#include "common.glsl"\n#include "brdf.glsl"\n\nuniform sampler2D uNormalSampler;\n\n#ifdef USE_BASE_COLOR_MAP\nuniform sampler2D uBaseColorSampler;\n#endif\n\n#ifdef USE_MATERIAL_MAP\nuniform sampler2D uMaterialSampler;\n#endif\n\nuniform vec3 uBaseColor;\nuniform float uMetalness;\nuniform float uRoughness;\n\n#ifdef IS_POINT_LIGHT\nuniform vec3 uLightPosition;\n#endif\n\n#ifdef USE_SSS\nuniform float uSubSurfaceScattering;\n#endif\n\n#ifdef IS_DIRECTIONAL_LIGHT\nuniform vec3 uLightDirection;\n#endif\n\nuniform vec3 uLightColor;\nuniform float uViewportAspect;\nuniform float uScale;\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\n\n#ifdef USE_SINGLE_PASS\n#include "ambient.glsl"\n#endif\n\nconst vec3 eye = vec3(0.5, 0.5, 100.0);\n\nfloat attenuation(float distance){\n    return  1.0/(distance*distance);\n}\n\nvec3 rgbToNormal(vec3 rgb){\n    return normalize(rgb - vec3(0.5));\n}\n\nvoid main(){\n    vec4 normalSample = texture2D(uNormalSampler, vUv);\n    float alpha = normalSample.a;\n    vec3 normal = rgbToNormal(normalSample.rgb);\n#ifdef USE_SSS\n    vec4 diffuseNormalSample = texture2D(uNormalSampler, vUv, uSubSurfaceScattering);\n    vec3 diffuseNormal = rgbToNormal(diffuseNormalSample.rgb);\n#else\n#define diffuseNormal normal\n#endif\n\n    float metalness = uMetalness;\n    float roughness = uRoughness;\n\n#ifdef USE_MATERIAL_MAP\n    vec4 materialSample = texture2D(uMaterialSampler, vUv);\n    metalness *= materialSample.r;\n    roughness *= materialSample.g;\n    float occlusion = materialSample.b;\n#endif\n\n    metalness = saturate(metalness);\n    roughness = clamp(roughness, EPSILON, 1.0);\n\n    vec3 baseColor = uBaseColor;\n\n#ifdef USE_BASE_COLOR_MAP\n    vec4 baseColorSample = texture2D(uBaseColorSampler, vUv);\n    baseColor *= gammaDecode(baseColorSample.rgb);\n#endif\n\n    vec3 diffuseColor = mix(baseColor, vec3(0.0), metalness);\n    // ?\n    vec3 specularColor = mix(vec3(0.04), baseColor.rgb, metalness)*0.5;\n\n#ifdef IS_POINT_LIGHT\n    vec3 lightOffset = vPosition - uLightPosition;\n    lightOffset.y /= uViewportAspect;\n    float lightDistance = length(lightOffset);\n    float falloff = attenuation(lightDistance);\n    vec3 lightDirection = lightOffset/lightDistance;\n#endif\n\n#ifdef IS_DIRECTIONAL_LIGHT\n    float falloff = 1.0;\n    vec3 lightDirection = uLightDirection;\n#endif\n\n    vec3 eyeDirection = normalize(eye - vPosition);\n    vec3 diffuse = max(0.0, -dot(diffuseNormal, lightDirection))*diffuseColor;\n    // linear = vec3(roughness);\n    vec3 specular = brdf_ggx(normal, -lightDirection, eyeDirection, specularColor, roughness);\n    vec3 intensity = (diffuse+specular)*falloff;\n\n#ifdef USE_MATERIAL_MAP\n    intensity *= occlusion;\n#endif\n\n    vec3 linear = uLightColor*intensity;\n    // linear = specularColor;\n    // linear.r = metalness;\n    // linear = vec3(uRoughness*materialSample.g == materialSample.g ? 1.0 : 0.0);\n    // linear.b = occlusion;\n\n    gl_FragColor = vec4(linear, alpha);\n\n#ifdef USE_SINGLE_PASS\n    gl_FragColor = gammaEncode(gl_FragColor);\n#ifdef USE_AMBIENT_MAP\n   addAmbient(gl_FragColor);\n#endif\n#endif\n\n}\n'},{}],10:[function(e,n,r){n.exports='precision highp float;\n#include "common.glsl"\n#include "fxaa.glsl"\n\nuniform sampler2D uFrameBufferSampler;\nuniform vec2 uFrameBufferResolution;\n\nvarying vec3 vPosition;\n\n#ifdef USE_AMBIENT_MAP\nvarying vec2 vUv;\n#endif\n\n#include "ambient.glsl"\n\nvoid main(){\n#ifdef USE_FXAA\n    // fxaa does gammaEncode .. for now\n    vec4 frameBuffer = fxaa(vec2(vPosition.x, 1.0 - vPosition.y), uFrameBufferResolution, uFrameBufferSampler);\n#endif\n#ifndef USE_FXAA\n    vec4 frameBuffer = gammaEncode(texture2D(uFrameBufferSampler, vec2(vPosition.x, 1.0 - vPosition.y)));\n#endif\n    gl_FragColor = frameBuffer;\n// assume SRGB\n#ifdef USE_AMBIENT_MAP\n   addAmbient(gl_FragColor);\n#endif\n}\n'},{}],11:[function(e,n,r){n.exports="attribute vec3 aPosition;\n#ifdef USE_AMBIENT_MAP\nvarying vec2 vUv;\n#endif\n\nvoid main(){\n    vUv = vec2(0.5)-(aPosition.xy)*vec2(-0.5, 0.5);\n    gl_Position = vec4(aPosition, 1.0);\n}\n"},{}],12:[function(e,n,r){n.exports="attribute vec3 aPosition;\n\nuniform float uScale;\nuniform float uTextureAspect;\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\n\nvoid main(){\n    vPosition = vec3(vec2(0.5)-(aPosition.xy)*vec2(-0.5, 0.5), 0);\n    vUv = vPosition.xy * uScale * vec2(1.0, 1.0/uTextureAspect);\n    gl_Position = vec4(aPosition, 1.0);\n}\n"},{}]},{},[2])(2)});